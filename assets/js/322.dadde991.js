(window.webpackJsonp=window.webpackJsonp||[]).push([[322],{909:function(e,t,s){"use strict";s.r(t);var a=s(0),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"生成目录树-tree-node-cli"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成目录树-tree-node-cli","aria-hidden":"true"}},[e._v("#")]),e._v(" 生成目录树 tree-node-cli")]),e._v(" "),s("p",[e._v("在平常写项目文档的时候，经常需要项目的文档树，类似这样：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("ts-node-project\n├── src\n│   └── index.ts\n└── package.json\n")])])]),s("p",[e._v("那这个是怎么生成的呢？有两种方法：")]),e._v(" "),s("h2",{attrs:{id:"window-自带的命令行命令tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#window-自带的命令行命令tree","aria-hidden":"true"}},[e._v("#")]),e._v(" window 自带的命令行命令"),s("code",[e._v("tree")])]),e._v(" "),s("p",[s("strong",[e._v("语法：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("tree [<Drive>:][<Path>] [/F] [/A]\n\n<Drive >：\t指定包含要显示其目录结构的磁盘的驱动器。\n<Path >\t    指定要显示其目录结构的目录。\n/F\t        显示每个目录中的文件的名称。\n/A\t        指定树将使用文本字符而不是图形字符来显示链接子目录的行。\n/?\t        在命令提示符下显示帮助。\n")])])]),s("blockquote",[s("p",[e._v("如果未指定驱动器或路径，树将显示从当前驱动器的当前目录开始的树状结构。")])]),e._v(" "),s("p",[s("strong",[e._v("示例：")]),e._v("\n导出当前目录的文件夹/文件的目录树到 tree.txt 文件中。")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("tree /F "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("tree.txt\n")])])]),s("p",[e._v("但是这个命令选项太简单了，带来很多问题，比如一般项目中都有"),s("code",[e._v("node_modules")]),e._v("文件夹，项目路径嵌套很深，但是用这个命令没办法排除掉对该文件夹的解析。")]),e._v(" "),s("p",[e._v("所以如果是一个目录很深的话，会生成很大的树结构。")]),e._v(" "),s("p",[e._v("所以一般都采用第三方的树生成工具。")]),e._v(" "),s("h2",{attrs:{id:"在-git-bash-中使用tree-node-cli"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在-git-bash-中使用tree-node-cli","aria-hidden":"true"}},[e._v("#")]),e._v(" 在 Git Bash 中使用"),s("code",[e._v("tree-node-cli")])]),e._v(" "),s("p",[s("code",[e._v("tree-node-cli")]),e._v("是基于 node 的一个工具包：")]),e._v(" "),s("p",[s("strong",[e._v("全局安装：")])]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[e._v("npm")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" -g tree-node-cli\n")])])]),s("p",[s("strong",[e._v("命令选项：")])]),e._v(" "),s("p",[e._v("电脑上需要安装"),s("code",[e._v("Git")]),e._v("工具，然后右键打开"),s("code",[e._v("Git Bash")]),e._v("，输入"),s("code",[e._v("tree -h")]),e._v("查看所有命令选项：")]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("$ tree -h\nUsage: tree "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("options"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\nOptions:\n  -V, --version             输出版本号\n  -h, --help                输出使用方法\n\n  -a, --all-files           所有的文件，包括隐藏的文件，都会被打印出来。\n  --dirs-first              在树状结果中优先列出目录.\n  -d, --dirs-only           只输出目录结构.\n  -I, --exclude "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("patterns"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("  排除文件或文件夹。E.g. "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"node_modules|coverage"')]),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n  -L, --max-depth "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("       显示最大的层级深度.\n  -r, --reverse             按字母反序排列输出.\n  -F, --trailing-slash      为目录结尾添加 /\n")])])]),s("p",[s("strong",[e._v("示例：")])]),e._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 在 GIt Bash中输入")]),e._v("\n$ tree --dirs-first -L "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v(" -I "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"node_modules|.vscode"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("tree.md\n")])])]),s("p",[e._v("显示当前目录下 3 层文件结构，但排除"),s("code",[e._v("node_modules")]),e._v("和"),s("code",[e._v(".vscode")]),e._v("文件夹，并且以目录在前的形式输出到 tree.md 文件。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("ts-node\n├── src\n│   └── index.ts\n├── package.json\n├── tree.md\n├── tsconfig.json\n└── tslint.json\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);